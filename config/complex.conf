# =========================
# Global (applies to all servers unless overridden)
# =========================

# Where generic error pages live if a server doesn't override them.
error_page 404 /errors/404.html;      # Map HTTP 404 -> serve this path from the selected server's root
error_page 405 /errors/405.html;      # 405 Method Not Allowed page
error_page 413 /errors/413.html;      # 413 Payload Too Large page (body-limit failures)

# A conservative default request-body limit for uploads/POSTs (can be overridden per server).
client_max_body_size 1m;              # Requests with larger bodies should be rejected with 413

# =========================
# Server A: a website on 127.0.0.1:8080 with hostname routing
# =========================
server {
    listen 127.0.0.1:8080;            # Interface:port pair to accept TCP connections on
    server_name example.com www.example.com;  # Host header(s) this server answers; used when multiple servers share a port

    root /srv/www/example;            # Filesystem base for resolving request URIs into files
    index index.html index.htm;       # Default file(s) when the URI maps to a directory
    client_max_body_size 5m;          # Override global: allow up to 5 MB on this server

    error_page 404 /errors/404.html;  # Override or confirm the 404 page for this server
    error_page 500 /errors/500.html;  # Custom 500 (CGI or internal error) page

    # -------- Routing rules (prefix matches) --------

    location / {                      # Root route: everything not matched more specifically
        allow_methods GET HEAD;       # Only serve static reads; POST/DELETE here should 405
        autoindex off;                # If a directory has no index file, do NOT list its contents
    }

    location /images/ {               # Static assets under /images/
        root /srv/assets/images;      # Re-root this subtree elsewhere on disk
        allow_methods GET HEAD;       # Read-only
        autoindex on;                 # OK to list directory contents if no index file is present
    }

    location /old {                   # Simple redirect rule
        return 301 /new;              # Permanent redirect /old -> /new (same host)
    }

    location /uploads/ {              # End-user uploads endpoint
        allow_methods POST;           # Only POST allowed here
        upload_store /srv/uploads;    # Directory on disk where request bodies get stored
        autoindex off;                # Do not list uploaded files
    }

    location /app/ {                  # Dynamic app via CGI (by extension)
        allow_methods GET POST;       # GET to render, POST to submit forms
        cgi_ext .php;                 # Extensions that should trigger the CGI runner
        cgi_path /usr/bin/php-cgi;    # Executable to run when a .php resource is requested
        cgi_working_dir /srv/www/example/app;  # Process working dir (for relative paths/includes)
        # Implementation hints for your server:
        # - Provide CGI with correct env vars (REQUEST_METHOD, QUERY_STRING, CONTENT_LENGTH,
        #   CONTENT_TYPE, SCRIPT_NAME, PATH_INFO, SERVER_NAME, SERVER_PORT, etc.).
        # - If request is chunked: de-chunk before invoking CGI; CGI reads until EOF.
        # - If CGI omits Content-Length: stream to client until EOF.
    }
}

# =========================
# Server B: separate site on a DIFFERENT port & hostname
# =========================
server {
    listen 127.0.0.1:8081;            # Different port -> different "virtual host" by socket
    server_name api.local;            # Distinct hostname (test with curl --resolve)

    root /srv/www/api;                # Filesystem root for this server
    index index.html;                 # Default file for directory URIs
    client_max_body_size 100k;        # Much stricter body limit on this server

    error_page 404 /errors/notfound.html;  # This server uses a different 404 page

    location / {                      # JSON-ish API surface
        allow_methods GET POST DELETE;# Explicitly allow DELETE here to test method filtering
        default_type application/json;# If you implement content-types, default to JSON
        autoindex off;                # No directory listing for API
    }

    location /v1/health {             # Soft redirect example (temporary)
        return 302 /status;           # 302 redirect to /status
    }

    location /scripts/ {              # CGI for Python scripts
        allow_methods GET POST;       # Scripted endpoints can accept GET & POST
        cgi_ext .py;                  # Only .py under /scripts are executed
        cgi_path /usr/bin/python3;    # Interpreter to run
        cgi_working_dir /srv/www/api/scripts; # Where the script runs (relative file access)
    }
}